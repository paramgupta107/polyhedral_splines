/* Based on code by Jorg Peters */

#include "STEPWriter.hpp"

namespace STEPWriterVars {
const char* heading = 
"ISO-10303-21;\n"
"HEADER;\n"
"/* Based off file generated by software containing ST-Developer\n"
" * from STEP Tools, Inc. (www.steptools.com) by Fusion 360 from\n"
" * IGS file generated by PNS.\n"
" */\n"
"\n"
"FILE_DESCRIPTION(\n"
"/* description */ (''),\n"
"/* implementation_level */ '2;1');\n"
"\n"
"FILE_NAME(\n"
"/* name */ '%s',\n"
"/* time_stamp */ '',\n"
"/* author */ (''),\n"
"/* organization */ (''),\n"
"/* preprocessor_version */ 'ST-DEVELOPER v19.2',\n"
"/* originating_system */ 'PNS',\n"
"/* authorisation */ '');\n"
"\n"
"FILE_SCHEMA (('AUTOMOTIVE_DESIGN { 1 0 10303 214 3 1 1 }'));\n"
"ENDSEC;\n"
"\n"
"DATA;\n"
"/* Header information */\n"
"#1=UNCERTAINTY_MEASURE_WITH_UNIT(LENGTH_MEASURE(0.000393700787401575),\n"
"#6,'DISTANCE_ACCURACY_VALUE',\n"
"'Maximum model space distance between geometric entities at asserted c\n"
"onnectivities');\n"
"#2=UNCERTAINTY_MEASURE_WITH_UNIT(LENGTH_MEASURE(0.000393700787401575),\n"
"#6,'DISTANCE_ACCURACY_VALUE',\n"
"'Maximum model space distance between geometric entities at asserted c\n"
"onnectivities');\n"
"#3=(\n"
"GEOMETRIC_REPRESENTATION_CONTEXT(3)\n"
"GLOBAL_UNCERTAINTY_ASSIGNED_CONTEXT((#1))\n"
"GLOBAL_UNIT_ASSIGNED_CONTEXT((#6,#10,#11))\n"
"REPRESENTATION_CONTEXT('','3D')\n"
");\n"
"#4=(\n"
"GEOMETRIC_REPRESENTATION_CONTEXT(3)\n"
"GLOBAL_UNCERTAINTY_ASSIGNED_CONTEXT((#2))\n"
"GLOBAL_UNIT_ASSIGNED_CONTEXT((#6,#10,#11))\n"
"REPRESENTATION_CONTEXT('','3D')\n"
");\n"
"#5=DIMENSIONAL_EXPONENTS(1.,0.,0.,0.,0.,0.,0.);\n"
"#6=(\n"
"CONVERSION_BASED_UNIT('inch',#9)\n"
"LENGTH_UNIT()\n"
"NAMED_UNIT(#5)\n"
");\n"
"#7=(\n"
"LENGTH_UNIT()\n"
"NAMED_UNIT(*)\n"
"SI_UNIT(.MILLI.,.METRE.)\n"
");\n"
"#8=(\n"
"LENGTH_UNIT()\n"
"NAMED_UNIT(*)\n"
"SI_UNIT($,.METRE.)\n"
");\n"
"#9=LENGTH_MEASURE_WITH_UNIT(LENGTH_MEASURE(25.4),#7);\n"
"#10=(\n"
"NAMED_UNIT(*)\n"
"PLANE_ANGLE_UNIT()\n"
"SI_UNIT($,.RADIAN.)\n"
");\n"
"#11=(\n"
"NAMED_UNIT(*)\n"
"SI_UNIT($,.STERADIAN.)\n"
"SOLID_ANGLE_UNIT()\n"
");\n"
"#12=SHAPE_DEFINITION_REPRESENTATION(#13,#14);\n"
"#13=PRODUCT_DEFINITION_SHAPE('',$,#20);\n"
"#14=SHAPE_REPRESENTATION('',(#15,#27),#3);\n"
"\n"
"#15=AXIS2_PLACEMENT_3D('',#18,#16,#17);\n"
"#16=DIRECTION('axis',(0.,0.,1.));\n"
"#17=DIRECTION('refdir',(1.,0.,0.));\n"
"#18=CARTESIAN_POINT('',(0.,0.,0.));\n"
"\n"
"#19=PRODUCT_DEFINITION_CONTEXT('part definition',#24,'design');\n"
"#20=PRODUCT_DEFINITION('','',#21,#19);\n"
"#21=PRODUCT_DEFINITION_FORMATION('',$,#26);\n"
"#22=PRODUCT_RELATED_PRODUCT_CATEGORY('','',(#26));\n"
"#23=APPLICATION_PROTOCOL_DEFINITION('international standard',\n"
"'automotive_design',2009,#24);\n"
"#24=APPLICATION_CONTEXT(\n"
"'Core Data for Automotive Mechanical Design Process');\n"
"#25=PRODUCT_CONTEXT('part definition',#24,'mechanical');\n"
"#26=PRODUCT('','',$,(#25));\n"
"/* End of header */\n";

const char* ending =
"ENDSEC;\n"
"END-ISO-10303-21;";

const char* cartPoint = "#%d=CARTESIAN_POINT('Ctrl Pts',(%f,%f,%f));\n";
const char* vertPoint = "#%d=VERTEX_POINT('',#%d);\n";
const char* edgeCurve = "#%d=EDGE_CURVE('',#%d,#%d,#%d,.T.);\n";          // only ever use last arg of .T.
const char* orientedEdge = "#%d=ORIENTED_EDGE('',*,*,#%d,%s);\n";
const char* edgeLoop = "#%d=EDGE_LOOP('',(#%d,#%d,#%d,#%d));\n";

std::vector<std::string> lookUp = {"", "polyhedron", "triangular patch", "tensor-product patch with same degree in both directions",
                                   "general tensor-product patch", "rational Bezier tensor-product", "PN triangle patches", 
                                   "PN quads patches", "rational triangular patches"};
}

STEPWriter::STEPWriter(const std::string a_OutFile) : openShellLocs() {
    m_OutFile = fopen(a_OutFile.c_str(),"w");
    m_FileName = a_OutFile;
    m_CurrOffset = 30;                          // Start writing patches at element 30
    m_PatchNo = 0;
}

/*
 *  Destructor.
 *  All it does is close the file.
 */
STEPWriter::~STEPWriter() {
    fclose(m_OutFile);
}

/*
 *  Write the header information to the file
 */
void STEPWriter::start() {
    fprintf(m_OutFile, STEPWriterVars::heading, m_FileName.c_str());
    return;
}

/*
 *  Signals to WriteFromQueue to stop once
 *  it has processed all the patches in
 *  the queue.
 */
void STEPWriter::stop() {
    // Make surface
    fprintf(m_OutFile, "#27=SHELL_BASED_SURFACE_MODEL('Body1',");
    std::string temp_str = "(#" + std::to_string(openShellLocs[0]);
    for (int i = 1; i < openShellLocs.size(); i++)
        temp_str += ",#" + std::to_string(openShellLocs[i]);
    fprintf(m_OutFile, "%s));", temp_str.c_str());

    // Print closing tags
    fprintf(m_OutFile, STEPWriterVars::ending);
    return;
}

/*
 *  Process a patch
 */
void STEPWriter::consume(const Patch a_Patch) {
    writePatch(a_Patch);
    return;
}

void STEPWriter::writePatch(const Patch a_Patch) {
    // Check that the patch has the correct
    // number of control points for its degree
    if(!a_Patch.isValid())
    {
        std::cout << "Patch is not valid,  write is aborting!\n";
        return;
    }

    // Write patch out

    // TODO: Add code for this
    // const auto& xBB = a_Patch.m_BBcoefs[0];
    // const auto& yBB = a_Patch.m_BBcoefs[1];
    // const auto& zBB = a_Patch.m_BBcoefs[2];

    int numRows = a_Patch.m_DegU + 1;
    int numCols = a_Patch.m_DegV + 1;
    int numPts = numRows * numCols;

    fprintf(m_OutFile, "/* PATCH NO: %d; %s */\n", m_PatchNo++, STEPWriterVars::lookUp[atoi(a_Patch.m_PatchType.c_str())].c_str());
    int ctr = 0;
    for (int row = 0; row < numRows; row++) {
        for (int col = 0; col < numCols; col++) {
            const auto& pt = a_Patch.m_BBcoefs[row][col];
            fprintf(m_OutFile, STEPWriterVars::cartPoint, ctr+m_CurrOffset, pt[0], pt[1], pt[2]);
            ctr += 1;
        }
    }

    // Left side top to bottom
    fprintf(m_OutFile, "#%d=B_SPLINE_CURVE_WITH_KNOTS('',%d,(", m_CurrOffset+numPts, numRows - 1);
    std::string temp_str = "";
    for (int i = 0; i < numRows; i++) {
        temp_str += "#" + std::to_string(m_CurrOffset + i * numCols);
        if (i < numRows - 1)
            temp_str += ',';
    }
    // TODO: Check following (make sure knot multiplicities are correct)
    fprintf(m_OutFile, "%s),.UNSPECIFIED.,.F.,.F.,(%d,%d),(0.,1.),.UNSPECIFIED.);\n", temp_str.c_str(), numRows, numRows);

    // Bottom side left to right
    fprintf(m_OutFile, "#%d=B_SPLINE_CURVE_WITH_KNOTS('',%d,(", m_CurrOffset+numPts+1, numCols - 1);
    temp_str = "";
    for (int i = 0; i < numCols; i++) {
        temp_str += "#" + std::to_string(m_CurrOffset + numCols * (numRows - 1) + i);
        if (i < numCols - 1)
            temp_str += ',';
    }
    // TODO: Check the following (make sure knot multiplicities are correct)
    fprintf(m_OutFile, "%s),.UNSPECIFIED.,.F.,.F.,(%d,%d),(0.,1.),.UNSPECIFIED.);\n", temp_str.c_str(), numCols, numCols);

    // Right side top to bottom
    fprintf(m_OutFile, "#%d=B_SPLINE_CURVE_WITH_KNOTS('',%d,(", m_CurrOffset+numPts+2, numRows - 1);
    temp_str = "";
    for (int i = 0; i < numRows; i++) {
        temp_str += "#" + std::to_string(m_CurrOffset + (i + 1) * numCols - 1);
        if (i < numRows - 1)
            temp_str += ',';
    }
    // TODO: Check the following (make sure knot multiplicities are correct)
    fprintf(m_OutFile, "%s),.UNSPECIFIED.,.F.,.F.,(%d,%d),(0.,1.),.UNSPECIFIED.);\n", temp_str.c_str(), numRows, numRows);

    // Top side left to right
    fprintf(m_OutFile, "#%d=B_SPLINE_CURVE_WITH_KNOTS('',%d,(", m_CurrOffset+numPts+3, numCols - 1);
    temp_str = "";
    for (int i = 0; i < numCols; i++) {
        temp_str += "#" + std::to_string(m_CurrOffset + i);
        if (i < numCols - 1)
            temp_str += ',';
    }
    // TODO: (make sure knot multiplicities are correct)
    fprintf(m_OutFile, "%s),.UNSPECIFIED.,.F.,.F.,(%d,%d),(0.,1.),.UNSPECIFIED.);\n", temp_str.c_str(), numCols, numCols);

    // Edges
    fprintf(m_OutFile, STEPWriterVars::vertPoint, m_CurrOffset+numPts+4, m_CurrOffset+0);
    fprintf(m_OutFile, STEPWriterVars::vertPoint, m_CurrOffset+numPts+5, m_CurrOffset+numCols*(numRows - 1));
    fprintf(m_OutFile, STEPWriterVars::vertPoint, m_CurrOffset+numPts+6, m_CurrOffset+numCols*numRows - 1);
    fprintf(m_OutFile, STEPWriterVars::vertPoint, m_CurrOffset+numPts+7, m_CurrOffset+numCols - 1);
    fprintf(m_OutFile, STEPWriterVars::edgeCurve, m_CurrOffset+numPts+8, m_CurrOffset+numPts+4, m_CurrOffset+numPts+5, m_CurrOffset+numPts+0);
    fprintf(m_OutFile, STEPWriterVars::edgeCurve, m_CurrOffset+numPts+9, m_CurrOffset+numPts+5, m_CurrOffset+numPts+6, m_CurrOffset+numPts+1);
    fprintf(m_OutFile, STEPWriterVars::edgeCurve, m_CurrOffset+numPts+10,m_CurrOffset+numPts+7, m_CurrOffset+numPts+6, m_CurrOffset+numPts+2);
    fprintf(m_OutFile, STEPWriterVars::edgeCurve, m_CurrOffset+numPts+11,m_CurrOffset+numPts+4, m_CurrOffset+numPts+7, m_CurrOffset+numPts+3);
    fprintf(m_OutFile, STEPWriterVars::orientedEdge, m_CurrOffset+numPts+12, m_CurrOffset+numPts+8, ".T.");
    fprintf(m_OutFile, STEPWriterVars::orientedEdge, m_CurrOffset+numPts+13, m_CurrOffset+numPts+9, ".T.");
    fprintf(m_OutFile, STEPWriterVars::orientedEdge, m_CurrOffset+numPts+14, m_CurrOffset+numPts+10, ".F.");
    fprintf(m_OutFile, STEPWriterVars::orientedEdge, m_CurrOffset+numPts+15, m_CurrOffset+numPts+11, ".F.");
    fprintf(m_OutFile, STEPWriterVars::edgeLoop, m_CurrOffset+numPts+16, m_CurrOffset+numPts+12, m_CurrOffset+numPts+13, m_CurrOffset+numPts+14, m_CurrOffset+numPts+15);
    fprintf(m_OutFile, "#%d=FACE_OUTER_BOUND('',#%d,.T.);\n", m_CurrOffset+numPts+17, m_CurrOffset+numPts+16);

    // Surface
    // TODO: Check that degrees are lined up correctly
    fprintf(m_OutFile, "#%d=B_SPLINE_SURFACE_WITH_KNOTS('',%d,%d,(", m_CurrOffset+numPts+18, a_Patch.m_DegU, a_Patch.m_DegV);
    ctr = 0;
    for (int row = 0; row < numRows; row++) {
        temp_str = "(";
        for (int col = 0; col < numCols; col++) {
            temp_str += "#" + std::to_string(m_CurrOffset+ctr);
            if (col < numCols - 1)
                temp_str += ",";
            ctr +=1;
        }
        temp_str += ')';
        if (row < numRows - 1)
            temp_str += ',';
        
        fprintf(m_OutFile, temp_str.c_str());
    }
    // Check that multiplicities are correct order
    fprintf(m_OutFile, "),.UNSPECIFIED.,.F.,.F.,.F.,(%d,%d),(%d,%d),(0.,1.),(0.,1.),.UNSPECIFIED.);\n", numRows, numRows, numCols, numCols);

    // Face and shell
    fprintf(m_OutFile, "#%d=ADVANCED_FACE('',(#%d),#%d,.T.);\n", m_CurrOffset+numPts+19, m_CurrOffset+numPts+17, m_CurrOffset+numPts+18);
    fprintf(m_OutFile, "#%d=OPEN_SHELL('',(#%d));\n\n", m_CurrOffset+numPts+20, m_CurrOffset+numPts+19);

    // Store where the open shell is and increment the offset
    openShellLocs.push_back(m_CurrOffset+numPts+20);
    m_CurrOffset += numPts+21;

    return;
}